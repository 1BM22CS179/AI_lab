from heapq import heappush, heappop
from typing import Tuple, List, Dict

# Goal configuration stored as a tuple
GOAL = (1, 2, 3,
        4, 5, 6,
        7, 8, 0)

def misplaced_tiles(state: Tuple[int, ...]) -> int:
    """Counts how many tiles are not in their correct goal position."""
    return sum(
        1 for i in range(9)
        if state[i] != 0 and state[i] != GOAL[i]
    )

def manhattan_distance(state: Tuple[int, ...]) -> int:
    """Total Manhattan (grid) distance of tiles from their goal positions."""
    distance = 0
    for index, tile in enumerate(state):
        if tile == 0:
            continue  # Skip blank tile
        goal_index = GOAL.index(tile)
        r1, c1 = divmod(index, 3)
        r2, c2 = divmod(goal_index, 3)
        distance += abs(r1 - r2) + abs(c1 - c2)
    return distance

def get_neighbors(state: Tuple[int, ...]) -> List[Tuple[int, ...]]:
    """Returns all reachable states from the current state."""
    neighbors = []
    zero_pos = state.index(0)
    row, col = divmod(zero_pos, 3)

    possible_moves = []

    # Up
    if row > 0:
        possible_moves.append(zero_pos - 3)
    # Down
    if row < 2:
        possible_moves.append(zero_pos + 3)
    # Left
    if col > 0:
        possible_moves.append(zero_pos - 1)
    # Right
    if col < 2:
        possible_moves.append(zero_pos + 1)

    # Swap blank with each valid neighbor
    for move in possible_moves:
        lst = list(state)
        lst[zero_pos], lst[move] = lst[move], lst[zero_pos]
        neighbors.append(tuple(lst))

    return neighbors

def reconstruct_path(came_from: Dict, state: Tuple[int, ...]) -> List[Tuple[int, ...]]:
    """Reconstructs path from start to goal."""
    path = [state]
    while state in came_from:
        state = came_from[state]
        path.append(state)
    return path[::-1]

def a_star(start: Tuple[int, ...], heuristic="manhattan") -> List[Tuple[int, ...]]:
    """Runs A* using either Manhattan or Misplaced Tiles heuristic."""

    if heuristic == "manhattan":
        h = manhattan_distance
    elif heuristic == "misplaced":
        h = misplaced_tiles
    else:
        raise ValueError("Invalid heuristic name.")

    # Priority queue: entries are (f_score, g_cost, state)
    open_list = []
    heappush(open_list, (h(start), 0, start))

    came_from = {}
    g_cost = {start: 0}
    visited = set()

    while open_list:
        f, cost, state = heappop(open_list)

        if state == GOAL:
            return reconstruct_path(came_from, state)

        visited.add(state)

        for next_state in get_neighbors(state):
            if next_state in visited:
                continue

            new_cost = g_cost[state] + 1
            if next_state not in g_cost or new_cost < g_cost[next_state]:
                g_cost[next_state] = new_cost
                came_from[next_state] = state
                heappush(open_list, (new_cost + h(next_state), new_cost, next_state))

    return None  # Unsolvable puzzle

def print_state(state: Tuple[int, ...]):
    for i in range(0, 9, 3):
        print(state[i:i+3])
    print()

def main():
    start_state = (1, 2, 3,
                   4, 5, 0,
                   7, 8, 6)

    print("=== Solving using MISPLACED TILES heuristic ===")
    sol = a_star(start_state, heuristic="misplaced")
    if sol:
        print(f"Moves needed: {len(sol) - 1}")
        for step in sol:
            print_state(step)
    else:
        print("No solution found.")

    print("\n=== Solving using MANHATTAN heuristic ===")
    sol = a_star(start_state, heuristic="manhattan")
    if sol:
        print(f"Moves needed: {len(sol) - 1}")
        for step in sol:
            print_state(step)
    else:
        print("No solution found.")

if __name__ == "__main__":
    main()
